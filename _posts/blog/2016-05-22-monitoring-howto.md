---
layout: blog
category: blog
title: "DevOps 팀을 위한 모니터링 팁"
header-img: "img/career-bg-9.jpg"
date: 2016-05-22
author: namenu
published: true
description: "개발과 운영을 동시에 하느라 고통받는 DevOps를 위한 모니터링 꿀팁"
---

다음 중 몇 개나 해당하시나요?

* 1~5명 규모의 작은 개발팀에서 일한다.
* DevOps 조직이다.
* 우여곡절 끝에 서비스는 런칭했지만, 개발과 동시에 운영을 해야하는 상황이다.
* 서버 인프라 지식이 별로 없다.
* 무중단 서비스 운영 경험이 별로 없다.
* 팀 내에 시스템 엔지니어(SE)와 데이터베이스 전문가(DBA)가 없다.

하나라도 해당한다면 이 글이 도움이 될 지도 모릅니다.

누구나 쉽고 빠르게 앱을 만들고 서비스를 런칭할 수 있는 시대가 되었지만 문제는 런칭 이후입니다. 런칭 이후에는 트래픽이 많든 적든 [안정적인(High Availability)](https://en.wikipedia.org/wiki/High_availability) 서비스를 운영해야 하는 일이 항상 함께하기 때문입니다.

안정적인 서비스를 운영하기 위해서는 체계적인 모니터링이 필수라고 하는데 그마저도 쉽지 않습니다. 큰 문제가 터지기 전까지는 무엇을 모니터링 해야 하는지조차 모를 뿐더러, 개발해야할 것들이 산더미라 주말 밤낮으로 울려대는 알림을 신경쓸 여유도 없습니다.

리디북스 역시 모니터링이 전혀 없던 시절이 있었으나, 크고 작은 실패를 겪으며 조금씩 경험을 쌓아가고 있습니다. 이번 글에서는 저희가 모니터링과 관련하여 고민해 온 내용들을 소개해볼까 합니다.

---

# 무엇을 모니터링할 것인가


모니터링의 목적은 안정적인 서비스를 하기 위함입니다. 여기서 '안정적'이란 장애가 없고 균일한 품질을 제공하는 것을 의미합니다. 하지만 이 때 단순히 “장애=고장” 으로 간주하고 모니터링 대상을 “고장”으로 국한시켜서는 안됩니다. 서비스 이용에 지장이 없더라도 어떤 수치나 결과가 예상과 다르다면 잠재적인 장애 상황으로 간주하고 살펴보아야 합니다.

예를 들어, 웹서버의 평균 CPU 사용률이 70%가 넘는다거나 네트워크 대역폭을 90% 이상 사용하는 상황은 정상이 아닙니다. 조금만 트래픽이 몰려도 문제가 발생할 가능성이 매우 높은 상황이기 때문에 잠재적인 장애로 간주해야겠죠.

또 장애는 그 심각도에 따라서도 구분해야 하는데, 처음부터 너무 상세하게 구분할 필요는 없습니다. 크게 서비스 이용에 치명적인 장애를 주는 것과 그렇지 않을 것으로 나누어 생각하면 됩니다. “치명적”의 의미는 서비스마다 다를 수 있지만 사업에 지장을 초래하거나, 고객을 잃을 수 있는 수준이라면 치명적이라고 보아야 합니다.

위 기준으로 장애의 종류를 구분해보면 4가지 조합이 나옵니다.


<!--
|               | 발생중 (On-going) | 잠재적 (Potential) |
|---------------|-----------------|------------------|
| **심각함** | 핵심 기능이 동작하지 않음 <br>웹사이트 접속이 안됨 | Master DB 장애 <br>백업 스크립트 오동작 |
| **심각하지 않음** | 로그 수집이 누락됨 <br>사무실 무선인터넷이 안됨 | RAID6 구성 디스크의 마모<br>OS의 서비스기간이 종료됨 |
-->

<img src="//i.imgur.com/OoSU4br.png" alt="종류에 따른 장애 구분" class="center" style="max-width: 503px" />
<figcaption>종류에 따른 장애 구분</figcaption>


장애의 종류를 구분한 이유는 장애 대응 및 예방에 투입되는 리소스의 적정선을 찾기 위함이었습니다. 적정선이 없이 완벽함을 추구하면 할 수록 기하급수적인 노력이 들어가기 때문입니다. 그리고 각 구분에 대해서는 내부적으로 아래와 같은 원칙을 정하였습니다.

<br>

<img src="//i.imgur.com/PIWVeUs.png" alt="장애 종류에 따른 대응 원칙" class="center" style="max-width: 503px" />
<figcaption>장애 종류에 따른 대응 원칙</figcaption>

이러한 원칙은 해야할 일을 4가지로 분류하는 [아이젠하워 의사결정 매트릭스](https://en.wikipedia.org/wiki/First_Things_First_(book))에서 차용하였는데, 시사하는 바도 동일합니다. 즉, 중요한 것은 대부분 긴급하지 않고, 긴급한 것은 대체로 중요하지 않다는 점입니다.

당연한 이야기일 수 있지만, 항상 의식하고 놓치지 말아야 하는 것은 잠재적이며 심각한 장애(2번)입니다. 모니터링은 한 번 시작하게 되면 관리를 위한 비용이 꾸준히 투입되어야 하기 때문에 사소한 문제(3, 4번)를 굳이 파헤치는 것은 오히려 독이 될 수도 있습니다.

모니터링 측면에서 본다면 발생중인 장애는 최대한 빨리 발견하는 것이 중요하며, 잠재적인 장애는 상태의 변화를 최대한 빨리 감지하는 것이 중요합니다. 예를 들어, 디스크의 여유공간은 완전히 바닥나기 전까지 어떠한 경고도 나타나지 않지만 부족한 상황이 발생하면 어떤 부작용이 생길지 예측할 수 없습니다.

---

# 필수 모니터링 갖추기

모니터링을 해야할 대상은 기술 스택과 코드 구현에 따라 달라지겠지만, 빼놓을 수 없는 것들이 몇 가지 있습니다. 리디북스에서는 서버의 프로비저닝과 동시에 아래 내용들을 함께 준비하고 있습니다.

## 1. 리소스 및 시스템 모니터링
 
각종 시스템 리소스 및 하드웨어 상태는 필수 모니터링 대상입니다. 모니터링 툴을 설치해보면 측정해주는 항목들이 너무 많아서 당황스러운 경험을 하게 되는데요. 아래는 리디북스가 백엔드를 운영하면서 주목하게된 항목들입니다.

- CPU Usage
- Load Average
- Disk Usage
- Disk Utilization
- Swap Memory Usage (사용시)
- Temperature (인프라 직접 구축시)
- RAID Status (인프라 직접 구축시)
- S.M.A.R.T Errors (인프라 직접 구축시)

위 항목들에 대한 모니터링은 생각보다 훨씬 중요합니다. 이 중 몇가지는 [New Relic](https://newrelic.com/server-monitoring) 에서 무료로 지원하므로 당장 여력이 없다면 이를 이용하는 것도 좋은 방법입니다.

클라우드 환경이 아닌 데이터센터에서 인프라를 직접 구축하여 운영하고 있다면 좀 더 많은 노력이 필요합니다. 하드웨어적인 장애를 직접 신경써야 하기 때문입니다. 실제로 팬(fan)이 고장나거나 케이블이 환풍구를 막아서 서버의 온도가 비정상적으로 높아지다가 기기가 오동작하는 어처구니없는 상황도 발생합니다.

서버 환경에서 SSD 사용이 점점 대세가 되어가고 있는데, 최근 [구글이 공개한 정보](http://www.zdnet.com/article/ssd-reliability-in-the-real-world-googles-experience/)에 따르면 SSD에서 배드블럭이 발생하는 일은 매우 흔하며, 시간이 오래될 수록 안정성이 떨어진다고 합니다.

따라서 디스크와 관련된 RAID나 S.M.A.R.T 오류는 RAID 가능한 빨리 대응해야 합니다. 특히 RAID 장비를 구성할 때에는 같은 공정에서 출하된 같은 벤더의 제품을 일괄적으로 구매해서 사용하기 때문에, 동일한 하드웨어 결함을 지니고 있거나 평균 수명도 비슷하므로 결코 안이하게 대응해서는 안됩니다.

리디북스에서는 전자책 원본을 보관하는 스토리지에서 4개의 사본(replica) 중 3개가 연달아 깨지는 끔찍한 사고를 경험한 이후로, 디스크 오류는 1순위로 대응하고 있습니다. 참고로 스토리지 서버를 구축한지 3년째가 되는 해였고, 모두 [S사의 제품](http://namu.wiki/w/Seagate#s-3.3)이었습니다.

<br>

![RAID의 중요성](https://i.imgur.com/wYxMH4J.gif){: .center }
<figcaption>RAID의 중요성</figcaption>

Load Average(평균 부하)는 마치 서버의 종합 성적표 같아서, 이 역시 주목할 필요가 있습니다. Load Average에 변동이 생긴다면 평소와는 다른 처리량(throughput)을 내고 있다는 뜻입니다. 요청량이 증가하여 수치가 올라갔다면 서버 증설과 튜닝에 대비해야 하지만, 그렇지 않다면 어딘가 병목이 발생하여 처리 효율이 낮아졌다는 신호입니다.

아직 Load Average를 모니터링하고 있지 않다면 주요 서버군부터 아래 규칙을 참고하여 초기 기준치를 설정하기를 권장합니다. 물론 어디까지나 초기 설정 값이며, 실제 상황에 적합하지 않을 수 있습니다.

> Warning Level : 0.7 * number of cores <br>
> Critical Level : 1.0 * number of cores


간혹 커널 자체에 문제가 있거나, 커널 모드에서 예외가 발생하는 경우에는 syslogd 데몬이 남기는 로그를 파악해야 합니다. [Papertrail](https://papertrailapp.com/
), [Splunk](https://www.splunk.com/), [Loggly](https://www.loggly.com/) 등의 서비스는 크리티컬 수준 이상의 syslog 에 대해 알림을 설정할 수 있을 뿐 아니라,
텍스트 형태로 남겨지는 모든 로그에 대한 관리를 쉽게 도와줍니다. 비록 유료지만 커널 모니터링 용으로만 사용한다면 비용이 많이 들지 않습니다.

 
## 2. 응용프로그램 모니터링

앱이나 서버에서 발생하는 크래시와 예외를 수집하는 도구 역시 장애 예방에 필수입니다. 해당 기능을 실시간으로 제공하는 다양한 서비스들이 존재하는데 많이 쓰이는 것으로는 [Sentry](https://www.getsentry.com/), [Rollbar](https://rollbar.com/), [Airbrake](https://airbrake.io/), [NewRelic APM](http://newreilc.com/application-monitoring) 등이 있습니다. 대부분 5분만에 설정이 가능한데다 어느것을 선택하더라도 핵심 기능에는 부족함이 없습니다.

단, 현재까지 가성비로는 Sentry가 제일 뛰어납니다. Python의 Flask와 Jinja의 개발자로 유명한 Armin Ronacher가 팀에 합류했기에 발전가능성 측면에서도 많은 기대가 됩니다.

![Sentry의 실시간 에러 대시보드](https://i.imgur.com/EQ216Mn.jpg){: .center }
<figcaption>Sentry의 실시간 에러 대시보드</figcaption>


## 3. 데이터베이스 모니터링

팀에 DBA가 있나요? 모든 서버 개발자들이 인덱스와 스토리지 엔진의 특징에 대해 잘 이해하고, DB를 능숙하게 다루나요? 그것도 아니라면 개발자들이 작성한 모든 스키마워 쿼리에 대한 검증 과정을 거치고 있나요? 만약 그렇지 않다면 슬로우쿼리 모니터링은 필수입니다.

우리가 서비스 초기에 겪은 문제의 대부분은 인덱스를 잘 다루지 못하거나 새로 도입한 ORM에 대한 이해도가 낮아서 발생한 문제였습니다. 그리고 대부분은 특정 쿼리가 너무 많은 I/O를 유발하던 것이 원인이었으며, 작고 가벼운 쿼리가 너무 많이 호출되어 문제가 된 경우는 거의 없었습니다.

잘못 설계된 스키마나 쿼리는 평소에는 드러나지 않다가 사용자가 몰리기 시작하면 기하급수적으로 부하를 발생시켜서 기어이 서비스를 마비시키곤 합니다. 문제가 커지기 전에 그 조짐을 감지할 수는 없을까? 고민 끝에 우리가 시도한 방법은 “2초 이상 수행되는 쿼리에 대해서 로그를 남기고, 초당 3개 이상 로그가 발생할 경우 알림”을 받도록 하는 것이었습니다.

우리가 시도했던 방법은 2초이상 수행되는 쿼리에 대해 로그를 남기는 것이었습니다. MySQL에서는 아래 설정으로 로그를 활성화시킬 수 있습니다.

~~~ conf
[mysqld]
long_query_time=2  # 2초 이상 수행되는 쿼리에 대해서
slow_query_log=1   # 로그를 남겨주세요
~~~

쿼리 분석에는 Percona의 [pt-query-digest](https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html) 를 추천합니다. [VividCortext](https://www.vividcortex.com/monitoring/mysql/) 혹은 [MONyog](https://www.webyog.com/product/monyog) 등의 솔루션은 시각적으로 화려하고 실제로도 강력한 기능을 갖추고 있지만, 유료라는 큰 단점이 있습니다.

![똑똑. 누구시죠? 슬로우쿼리입니다.](https://i.imgur.com/iMeR94W.png){: .center }
<figcaption>부하가 감지될 경우 최근 쿼리 리포트를 받아보는것 만으로도 큰 도움이 됩니다.</figcaption>

모니터링을 통해 알림을 받게 되면 문제가 더 커지기 전에 해당 기능을 수정하거나 중단시킬 기회가 생깁니다. 특히 새롭게 추가한 기능을 배포할 때 서비스가 불안해 질 수 있는데, 퍼포먼스 문제를 미리 발견하고 롤백을 서두를 수 있다는 것도 장점입니다.

물론 가장 이상적인 상황은 n초 이상 수행되는 쿼리를 모두 없애는 것입니다. 하지만 현실은 튜닝을 포기하고 테이블을 풀스캔하도록 두는게 나은 선택일 수 있으며, OLAP/ETL 인프라가 별도로 구축되어 있지 않은 상황에서는 어쩔 수 없이 슬로우쿼리가 발생하게 됩니다. 저희가 초당 로그 갯수로 판단을 하게된 것도 이러한 이유 때문이었습니다.


## 4. 배치 작업(scheduled task) 모니터링

매일 백업 스크립트를 돌리고는 있는데, 백업이 정상적으로 완료가 되었는지는 어떻게 판단하면 될까요? 에러는 위에서 설명한 도구들로 확인이 가능하겠지만 스크립트가 수행도중 멈춰버렸거나, 서버의 전원이 꺼졌다면?
게다가 크론 작업(crontab)이 수십개가 넘어가면 이를 수동으로 체크하는 것도 일이므로, 반드시 자동화해야 합니다.

이러한 상황에서 활용할 수 있는 유용한 도구가 [PushMon](http://www.pushmon.com/) 입니다.
PushMon은 정해진 시간에 ping을 보내지 않으면 이메일이나 SMS로 알림을 주는 서비스로, 원리는 매우 단순하나 없어서는 안될 기능을 "무료"로 제공합니다.

---


## 모니터링에 대응하기

모니터링을 효율적으로 하기 위한, 즉 서비스 안정성을 높이기 위한 핵심 원칙은 “필요한 인원이 필요한 알림만 받는것”입니다.

알림이 너무 많이 와서 음소거(Mute)를 하고 싶은 생각이 든다면 모니터링 체계에 문제가 있다는 신호입니다. 불필요하게 많은 경고는 안전 불감증을 낳을 뿐더러 정작 중요한 경고를 놓칠 확률을 높이기 때문입니다. 치명적인 알림은 모든 채널로 즉각 수신하고, 경고성 알림은 메일로 수신하되 정기 리포트나 메일함 자동분류 기능을 이용하여 중요한 정보를 놓치지 않는 습관이 중요합니다.

불필요하게 많은 인원이 알림을 받는 상황도 문제입니다. 알림 수신자를 늘리면 모니터링의 퀄리티가 높아질 것이라고 생각하지만 절대 그렇지 않습니다. 오히려 [방관자 효과](https://ko.wikipedia.org/wiki/%EB%B0%A9%EA%B4%80%EC%9E%90_%ED%9A%A8%EA%B3%BC)가 발생하여 아무도 알림에 대응하지 않는 상황이 발생하게 됩니다. 따라서 알림이 발생했을 때에는 1차, 2차 담당자를 사전에 지정하고 운영할 필요가 있습니다.

![방관자 효과의 적절한 예](https://i.imgur.com/0TBF9Dr.gif){: .center }
<figcaption>방관자 효과의 적절한 예</figcaption>

팀에서 [Slack](https://slack.com)을 사용한다면 기능 연동을 통해 실시간으로 이슈를 파악할 수 있고, 담당자 지정을 보다 쉽고 명확하게 할 수 있습니다. 특히, 별것 아닌 이모티콘(emoji) 만으로도 방관자 효과를 크게 줄일 수 있는데, 예를 들면 아래와 같습니다.

> 👀 - 확인중 <br>
> ✅ - 확인 완료 <br> 
> 😱 - 확인은 하였으나 나는 해결을 못하겠음

![Sentry를 Slack에 연동한 모습](https://i.imgur.com/54YxUPu.png){: .center .box-shadow }
<figcaption>Sentry를 Slack에 연동한 모습</figcaption>


또한, 모니터링 시스템에 대한 모니터링도 중요합니다. SaaS를 이용하는 경우에는 최악의 경우 해당 서비스의 점검기간에 대비할 수 없으며, 심지어는 점검중이라는 사실 조차 인지하지 못할 수 있습니다. 이에 대비하기 위해 리디북스에서는 [Server Density](https://www.serverdensity.com/monitor-monitoring/)로 모니터링을 모니터링하고 있습니다.


## 맺음말

장애를 얼마나 꼼꼼하게 예방하는지, 그리고 얼마나 즉각적으로 반응하는지는 팀 구성원의 실력으로 정해지는것이 아니라 팀의 문화와 원칙에 따라 정해집니다. 아직 팀에 뚜렷한 대응 원칙이 없다면 먼저 상황에 맞는 기준과 척도를 결정하고 공유해볼 것을 추천합니다.

무엇보다 DevOps를 수행하는 것은 사람임을 잊지 말아야 합니다. 인간은 99.99% 가용성이나 24/7 을 보장하지 못하며, Uptime은 하루도 되지 않습니다. 최근 DevOps가 대세가 되어가지만 Ops에서의 인간적인 측면은 진지하게 고려되지 않고 있습니다. 이러한 환경을 개선하기 위한 [HumanOps](http://www.humanops.com/)에 대한 소개와 함께 글을 마칩니다.

<br>

&nbsp;&nbsp;&nbsp;&nbsp; **HumanOps 계명**

1. 시스템을 만들고 고치는 것은 인간이다.
2. 인간은 지치고 스트레스를 받으며, 행복과 슬픔을 느낀다.
3. 시스템은 아직 감정이 없다. 오로지 SLA만 있다.
4. 인간은 스위치 온/오프 상태를 반복해야 한다.
5. 시스템을 운영하는 인간의 행복이 시스템의 안정성에 영향을 준다.
6. 빈번한 알림 == 인간의 피로
7. 최대한 자동화하고, 최후의 수단으로 인간에게 이관하라.
8. 문서화하고, 훈련하고, 시간을 아껴라.
9. 창피 주지 마라.
10. 인간의 문제는 시스템의 문제다.
11. 인간의 건강은 사업의 건강에 영향을 준다.
12. 인간 > 시스템


---


*현재 리디북스는 서비스 인프라와 서지정보의 이상(anomaly)을 검증하기 위한 다양한 도구들을 직접 개발하여 활용하고 있습니다. 이러한 도구들을 함께 개발하며 건강한(?) 모니터링 문화를 만들어나갈 개발자를 찾고 있습니다.*
